# Guiding Philosophy

*Group Hat v3* is a ground-up redesign of the Group Hat tool, guided by a set of core values focused on clarity, simplicity, and teacher-centric design. The goal is to create a maintainable codebase that a solo developer can easily work on and explain, while delivering a robust, user-friendly tool for educators. All major decisions are evaluated against these principles to ensure they align with the project’s spirit.

* **Self-Documenting & Readable Code:** The code structure should serve as its own documentation. We use clear naming and organize features logically (for example, file-based routing mirrors user-facing pages). A developer should understand the app’s high-level layout just by looking at the repository structure. We prefer straightforward, explicit code over “clever” one-liners to maximize readability and ease of understanding.

* **Developer Experience over Performance:** Given the small scale of typical usage (a few classes of students at most), performance is a secondary concern to developer productivity. We favor technologies that make development and maintenance easier. For example, using a high-level framework like SvelteKit provides built-in routing, builds, and deployment, and TypeScript catches errors early and provides inline documentation of data models. A slight runtime overhead is acceptable in exchange for type safety, easier debugging, and a smoother development workflow.

* **Small, Testable Units of Code:** Functionality is broken into the smallest reasonable modules – pure functions for grouping algorithms, separate UI components, and dedicated services for data access. Each unit has a single responsibility and can be understood and tested in isolation. This modular approach makes the system easier to test (we can unit test business logic without a UI) and easier to change, since a modification in one module has limited impact on others. It avoids the v2 approach of mixing concerns (e.g. one large class managing data, UI, and state together), and instead decouples business logic from presentation.

* **Beginner-Friendly Simplicity:** The code should be approachable for relatively new programmers. We use common patterns and avoid overly abstract or clever techniques. For example, rather than an elaborate inversion-of-control setup, we’ll use clear imperative logic that mirrors real-world steps (a simple loop for assigning students to groups, etc.). We include comments and documentation to explain non-obvious logic in plain language. Using TypeScript also makes data structures explicit, effectively serving as documentation for anyone reading or contributing to the code.

* **Robustness Over Novelty:** Favor well-tested libraries and proven approaches over writing from scratch or using bleeding-edge tech. The aim is to minimize bugs and unforeseen issues. For instance, we use an established drag-and-drop library instead of a custom DnD implementation to handle edge cases across devices. We stick to mainstream frameworks (e.g. SvelteKit) rather than niche experimental ones, so that the project remains supportable by others. Fancy optimizations (web workers for algorithms, complex state management libraries, etc.) are deferred unless a clear need arises. In short, simpler solutions that are known to work reliably are chosen over ingenious but risky ones.

* **Teacher-Centered Design:** The tool must fit seamlessly into teachers’ workflows and be intuitive to use. This means minimal setup and a UI that matches expectations. We integrate with the tools teachers already use (like Google Sheets for data input/output) to reduce friction. We consider the teacher’s perspective in every feature: for example, providing an easy way to import preference data (no manual CSV uploads) and allowing exploration of multiple groupings without starting over. Features like “Undo” and the ability to save multiple configurations are prioritized because they let teachers experiment without fear. The UI is designed for the devices teachers commonly use (e.g. standard school-issued laptops with modest screen sizes), ensuring it works without requiring special hardware or high-resolution screens.

* **Privacy & Data Security (Privacy by Design):** Student data is sensitive, so the design treats it with utmost care. The single source of truth for student names and preferences remains the teacher’s Google Sheet; the app does **not** maintain its own database of student information. Wherever possible, the app handles only anonymized or ID-referenced data in memory and in transit. For example, if group assignments are cached or temporarily stored, we use internal IDs or hashed identifiers instead of student names to avoid exposing personal information. Student names are displayed only in the teacher’s browser and never persisted on our server. We avoid logging any sensitive data. In practice, this means even if the app’s server or storage were compromised, no raw student names or personal details would be leaked – only opaque IDs. This privacy-by-design approach aligns with school data policies and builds trust with users (teachers and schools).
