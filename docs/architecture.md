# Architecture Overview

*Group Hat v3* is a **standalone web application** (as opposed to a Google Sheets Add-On) built with a SvelteKit front-end and a Node/TypeScript back-end. It directly integrates with Google Sheets as its data source and follows a modular, layered design. This architecture addresses many shortcomings of the previous **v2** (p5.js) implementation by separating concerns, introducing a secure server component, and leveraging modern frameworks. *(For the guiding principles behind these choices, see the [Guiding Philosophy](philosophy.md) document. Key technical decisions are also documented in individual ADR files under `docs/adrs/`.)*

## Background: Why a Redesign (Lessons from v2)

The original Group Hat v2 prototype demonstrated the core concept but had several design and maintenance issues that v3 aims to solve. In summary, **v2** was a single-page canvas app with all logic on the client, and it suffered from:

* **Tightly Coupled Logic and UI:** The data model and rendering logic were intertwined (e.g. one class handled canvas drawing and group assignments together), making it hard to modify or test either in isolation.
* **Implicit Global State:** v2 relied on global browser state (e.g. global mouse coordinates for drag/drop), which made the code unpredictable and hard to understand outside of a running UI context.
* **No Direct Data Integration:** Teachers had to manually export Google Form results to CSV and import into the app; there was no direct Google Sheets connection. This process was tedious and error-prone.
* **No Persistence of Results:** All grouping work was lost on page refresh unless manually saved to a file. There was no mechanism to save outcomes back to a central location for later reference or sharing.
* **Lack of Typing and Tests:** The codebase was plain JavaScript with no type definitions and had no automated tests, making refactoring risky and understanding data structures difficult.
* **Limited UI Flexibility:** The UI was rendered on a fixed-size HTML canvas, leading to responsiveness issues (scrollbars on smaller screens, cut-off content) and accessibility limitations (canvas text is not screen-reader friendly, custom drag logic not accessible via keyboard).
* **Feature Gaps:** Some desirable features were missing or incomplete – e.g., exploring multiple grouping configurations easily, a clearer Undo/Redo interface, and any notion of user accounts or multi-user access.

These pain points set the stage for a new architecture in v3 focused on clarity, modularity, and integration.

## High-Level Architecture

To address the above issues, **Group Hat v3** is structured in three logical layers:

### Front-End (UI Layer – SvelteKit SPA)

The front-end is a SvelteKit application responsible for all user interaction and presentation. It runs primarily as a Single Page Application in the browser (with SvelteKit’s server-side rendering used for the initial page load). The UI layer handles rendering of student groups, drag-and-drop interactions for manual adjustments, and controls (buttons, forms) for actions like loading data or auto-assigning groups.

We chose **SvelteKit** as the front-end framework for its simplicity and developer-friendly features (file-based routing, built-in SSR, and an intuitive reactivity model). Svelte’s component syntax is similar to standard HTML/CSS/JS, which keeps the learning curve low. Compared to alternatives like React, Svelte requires less boilerplate and no complex state management libraries to get started. *(See [ADR-001](adrs/adr-001-sveltekit-over-react.md) for detailed rationale behind choosing SvelteKit over other frameworks.)*

The UI is organized into small, reusable Svelte components to mirror the app’s interface structure: for example, a main page component for the grouping interface, a `GroupCard` component for each group, and a `StudentItem` component for each student entry. This component-based design makes the UI code easier to understand and maintain. Key pieces include:

* **Main Page Component** – The primary screen (e.g. `routes/groups/+page.svelte`) which loads initial data (via SvelteKit’s `load` function calling our API) and holds the overall state (list of students, list of groups, current assignments). It also renders sub-components like toolbars and the group list.
* **GroupCard Component** – Represents a single group (e.g. a card or container showing the group’s name, capacity, and its members). It receives group data and the list of member IDs, and renders a list of StudentItem components (and possibly empty slots if the group isn’t full).
* **StudentItem Component** – Displays an individual student’s name (or initials) and possibly an indicator of their “happiness” or satisfaction (for example, coloring the border based on whether the student got one of their preferred groups). This component is kept simple and presentational, with any status computation done in the data layer and passed in as props.
* **Controls/Toolbar Component** – Contains UI controls like buttons for “Load Data”, “Auto-Assign”, “Undo”, “Redo”, etc. This can either be a distinct component (e.g. a top toolbar) or simply part of the main page, depending on how complex the controls become.

State management on the front-end uses Svelte’s reactive **stores**. For instance, we maintain a store for the current assignment of students to groups (mapping group IDs to arrays of student IDs). Components subscribe to this store so that when a student is moved to a new group, all affected components automatically update. This reactive approach eliminates the need for manual DOM updates that v2 required; when the underlying data changes, the UI reflects it. This makes the code simpler and less error-prone compared to the imperative updating in v2.

For **drag-and-drop interactions**, we leverage the open-source `svelte-dnd-action` library instead of writing our own drag logic. This library allows us to designate list containers as draggable zones and handles the full drag/drop lifecycle (including touch support and keyboard accessibility). When a teacher drags a student from one group to another, the library will trigger an update which we use to adjust the state (reassign the student to the new group). Using `svelte-dnd-action` aligns with our “robust, not fancy” principle – we rely on a well-tested solution to cover edge cases (such as dragging outside the window or scrolling during drag) and ensure accessibility, rather than reinventing these mechanics. The result is significantly less custom code and a more reliable UI.

Finally, the front-end is built to be **responsive** to different screen sizes. We use modern CSS (Flexbox/Grid) so that group containers wrap or scroll as needed on smaller screens. While teachers are likely on laptops (and the UI is optimized for typical laptop resolutions), the design will gracefully adjust to narrower windows or even tablet-sized screens. This is a marked improvement over v2’s fixed canvas approach, ensuring that the app remains usable without requiring specific screen dimensions.

### Back-End (Server/API Layer – SvelteKit Endpoints)

The back-end layer consists of server-side endpoints (API routes) within the SvelteKit application that handle data fetching and persistence. This layer’s primary role is integration with external services – in our case, Google Sheets – and encapsulating all sensitive operations (like authentication and data writes) away from the client.

**Key endpoints:**

* **`GET /api/data`** – Fetches the latest student, group, and preference data from the Google Sheet. When the front-end needs to load the class data, it calls this endpoint, and the server (using Google’s Sheets API) returns the data in JSON format. This design hides the details of Google Sheets access from the client; the browser just gets a ready-to-use data structure.
* **`POST /api/save`** – Writes back finalized group assignments to the Google Sheet (for example, adding a new sheet or table with the results). This allows the teacher’s grouping work to be saved in the spreadsheet for later reference or sharing. We may implement this as writing to a new tab in the sheet or some designated area, to avoid overwriting the original data. *(In the roadmap, this corresponds to adding a “Save” feature after grouping is done.)*

Under the hood, the server uses a **Google Service Account** credential to access the Google Sheets API securely. The service account’s email is pre-authorized to read and write the specific Google Sheet (the teacher will share the sheet with the service account beforehand). All sensitive credentials (service account keys, sheet ID, etc.) are stored in environment variables on the server – never exposed in client-side code – and SvelteKit’s server runtime handles the Google API calls.

For basic security of our API (since we have no user login yet), we implement a shared secret token mechanism and CORS restrictions. The environment includes an `AUTH_SHARED_SECRET`, and the front-end must send this token (for example, as a header) with each API request. The server validates this token to ensure that only authorized client calls are honored. Additionally, we restrict Cross-Origin requests to known allowed origins (configurable via an `ALLOWED_ORIGINS` env var) so that others cannot use our API endpoints from unauthorized websites. This lightweight security is sufficient for the single-tenant use case and much simpler than a full OAuth login system. *(For more on the decision to defer full user authentication, see [ADR-003](adrs/adr-003-no-auth-for-mvp.md).)*

By centralizing data access in these API routes, the architecture cleanly separates concerns: the front-end doesn’t need to know about Google API specifics or hold any credentials, and if we later support alternative data sources (another API, a database, etc.), we can modify or add server endpoints without impacting the UI layer. This also means that if we want to reuse core logic in another context (say, a command-line tool or a Google Sheets Add-on version in the future), we could bypass or replace this layer accordingly.

### Domain Logic (Core Data & Algorithm Layer)

At the heart of the application is the domain logic layer – the pure data models and algorithms that actually implement grouping functionality. This is not a separate deployed service, but a set of classes and functions (in TypeScript) that both the front-end and back-end can use. We isolate this logic so that it is independent of the UI framework and the Google API, making it reusable and easily testable.

Key domain elements include, for example:

* **Data Models:** Definitions for a `Student` (with properties like `id`, `firstName`, `lastName`, preferences, etc.), a `Group` (e.g. `id`, title, capacity, list of member IDs), and any other core concepts (perhaps a `Preference` or rules about grouping). These may be represented as TypeScript interfaces or classes. By having explicit data models, we get type safety throughout the app – if a function expects a `Student` object, the type system enforces that we pass the correct structure. This makes the code self-documenting and reduces bugs.
* **Grouping Algorithms:** Functions that implement the logic to assign students to groups. For example, a `randomAssign(students, groups)` function that randomly distributes students, or a `balancedAssign(students, groups, preferences)` that tries to maximize overall student “happiness” based on their choices while respecting group size limits and any “do not pair” constraints. These algorithms are pure functions (given input data, they produce an assignment without side effects). The algorithms can be unit-tested by feeding in sample data and verifying the output, independent of any UI. The front-end or back-end can call these functions as needed: e.g., when the teacher clicks “Auto-Assign”, the front-end might call a function from this layer to compute an assignment.

By keeping the domain logic separate, we ensure that business rules are defined in one place. If in the future we decide to integrate Group Hat into a different interface (say, a Google Sheets sidebar Add-On, or a mobile app), we can reuse these core classes and algorithms. It also means multiple parts of the system use the same logic – for instance, the back-end could use the same validation or assignment function to double-check data before saving, as the front-end used to display it.

This layered approach (UI, API, domain) yields a clear separation of concerns. The **UI layer** focuses on presenting data and handling user interactions. The **API layer** handles external communication and security. The **domain layer** encapsulates the core grouping functionality. Such separation makes the system more maintainable (each part can evolve somewhat independently), easier to test (domain logic can be tested without running a web server or UI), and extensible (we can replace or upgrade one layer with minimal changes to others, as long as the interfaces between layers remain consistent).

### Key Decisions and Alternatives

Throughout the design of this architecture, several important decisions were made with alternatives considered. The most significant ones are captured in our Architecture Decision Records (see the `docs/adrs/` directory). For example, the choice of **SvelteKit over React** for the front-end, opting for a **standalone web app vs. a Google Sheets Add-On**, and the decision to **delay implementing user login (OAuth)** are all documented with their context and reasoning. Contributors should refer to those ADRs for deeper insight into why certain approaches were taken over others.

## Future Functionality and Extensions

The above outlines the MVP architecture and features for Group Hat v3, aimed at a 40-hour initial development. Looking beyond the MVP, there are several areas where the system could be extended or improved in the future:

* **Enhanced Preference Handling:** Introduce more nuanced student preference inputs and constraints. For example, allow teachers to input pairs of students who should **not** be together, or rank preferences in multiple categories (topics of interest, teammate preferences, etc.). We could also provide a way for teachers to adjust how strongly preferences are weighted vs. other factors (e.g. a slider to favor first-choice preferences vs. ensuring mixed skill levels in each group). The architecture can accommodate this by extending the data model (adding fields for these preferences) and adjusting the grouping algorithm to account for them.

* **Advanced Grouping Algorithms:** Implement more sophisticated algorithms for forming groups. For instance, we could explore genetic algorithms or simulated annealing to optimize an overall “happiness” score across all students, especially for larger or more complex classes. Another idea is enabling the generation of **multiple distinct group configurations**—for example, creating several different grouping options so a teacher can choose the best one. We might also support “group rotation” scenarios (e.g. over a semester, create multiple group assignments such that the same pair of students is not repeated). Thanks to the clear separation of the algorithmic logic, we could even integrate external solvers or libraries if needed in the future without changing the UI or data integration layers.

* **User Accounts & Multi-Tenancy:** In the current design, the app is essentially single-tenant (one set of class data, configured via environment variables). If we wanted to open it up to multiple teachers or a wider audience, we would introduce user accounts (e.g. login with Google OAuth) and a database to separate each teacher’s data. Each user’s account could be associated with their own Google Sheet or data store. Our modular design would support this: for example, the API layer could be extended to include an authentication check on each request, and the sheet ID could be determined per user instead of a single global value. This would require additional infrastructure (user database, OAuth consent screens, etc.) but would be a logical next step if the tool grows. *(See ADR-003 for notes on deferring authentication in the initial version.)*

* **UI Improvements & Accessibility:** Ongoing refinement of the user interface is expected. This includes things like adding a quick search/filter to find students in a large class, improving visual indicators (e.g. clearly showing which groups are over or under capacity, highlighting conflicts), and providing helpful walkthroughs or tooltips for new users. Accessibility should be continuously improved: although using standard HTML elements already gives us a baseline of accessibility, we should ensure screen reader compatibility (e.g. ARIA labels where appropriate) and full keyboard navigability for all features. As we gather feedback from teachers, we’ll adjust the UI/UX to better fit their needs.

* **Mobile/Tablet Support:** Currently, we target laptop usage, but many teachers also use tablets (like iPads) or may want to quickly adjust groups on a tablet during class. We should ensure the app works well on touch devices. Using responsive design and the chosen drag-and-drop library (which already supports touch) puts us in a good position, but future testing on actual tablets and possibly adding mobile-specific UI tweaks (larger touch targets, different layout for smaller screens) will enhance usability on those devices.

* **Integration with Google Forms & Classroom:** Since student preference data originates from Google Forms, we could integrate directly with Forms or Classroom in the future. For example, we might allow the teacher to paste a Google Form URL and have the app fetch responses directly (bypassing the sheet, or configuring the sheet automatically). After forming groups, we could integrate with Google Classroom or Gmail to **publish results**: e.g. send each student an email with their group assignment, or post the groups to a Google Classroom announcement. These integrations would require expanding scopes and perhaps additional API endpoints or Google API usage, but would further streamline the teacher’s workflow by automating communication.

* **Analytics & Feedback for Teachers:** We could provide analytical feedback on the generated groups. For instance, the app could calculate a “happiness score” for a grouping (based on how many students got one of their top choices, how many undesirable pairings were avoided, etc.). If multiple configurations are generated, the app could compare them (e.g. “Configuration A satisfies 90% of first choices, Configuration B only 85% but keeps all specified pairs together”). Presenting such metrics can help teachers make informed decisions or justify the grouping to others. Additionally, capturing usage data (in a privacy-respecting way) might help identify common pain points or areas to improve.

In summary, the chosen architecture is designed not only to meet the immediate needs in the 40-hour rebuild but also to serve as a foundation for future growth. Each of the above enhancements could be added without fundamentally changing the architecture – a testament to the value of a modular, well-thought-out design from the start.
